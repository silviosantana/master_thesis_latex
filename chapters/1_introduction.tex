% ----------------------------------------------------------
% Introduction
% ----------------------------------------------------------
\chapter{Introduction}

Embedded Systems and \textit{Systems-on-Chip}~(SoC) are in the center of technological transformation of the modern world. \textit {Internet-of-Things}~(IoT), Industry 4.0, and Smart Systems are some growing markets that evidence these transformations and new design challenges. They reflect the rising complexity of these systems under different perceptions, such as power consumption, occupied area, scalability, and portability. In other words, this technological transformation expose an increasing demand for highly optimized systems, and therefore optimized processors. On the other hand, optimizing processors highlights an important concept of hardware design: \textit{Functional Safety}. This is because the more optimizations in a system, the more prone to error the design process becomes. Consequently, methods for hardware design verification also need to improve.

In the last decades, methods for hardware design have been based mainly on \textit{Hardware Design Languages}~(HDL), such as VHDL and Verilog, at the \textit{Register Transfer Level}~(RTL) \cite{paper-pdd}. For most cases, the RTL design represents the reference model for the system, or “\textit{golden model}”, and it is derived directly from specifications that are, in most cases, described in diagrams, or even in natural language. Traditional techniques for verification of digital designs include simulation with test benches and assertions \cite{paper-symbolic}. Considering the mentioned increase on the complexity of processors and SoCs, these verification methods become more costly and time consuming. Writing test benches to cover the specified scenarios, running simulations and analysing wave forms are some examples of that. These techniques are also known as “\textit{bug hunting}”, because they do not guarantee a \textit{bug-free} design. 

A higher-level description of the design, for instance the \textit{Electronic System Level}~(ESL), can be developed using programming languages like \textit{C++} associated with some special libraries such as \textit{SystemC}. Some advantages of ESL models are the relatively faster simulations, achieved by modelling communication as transactions instead of a cycle-accurate simulation, and well-established debugging tools. Furthermore, there are \textit{High-Level Synthesis}~(HLS) tools which allow these high-level descriptions to be used to generate the implementation of the design. Even though HLS tools have improved in the past years, it is still limited to be applied to some specific domains like signal processing algorithms \cite{paper-pdd}. 

One way to improve efficiency in the verification process is applying \textit{formal verification}~(FV) methods. In contrast to the conventional verification approach with simulation, FV methods uses properties to describe the behavior of the system and to check its correctness. It also allows to overcome the \textit{semantic gap} problem. The term semantic gap, applied to the hardware development world, refers to a gap between the specification of the system and its implementation, i.e. the implemented design does not fully cover the specified behaviour \TLSAY{not correct some implementation details (like timing and bit-wise operations are missing. It can still be correct. You just don't know.} . However, as previously stated, the specifications are in their majority described in natural language or in terms of diagrams. Thus, the System-Level models, e.g. ESL models, are kept as prototypes used for validation of functional and non-functional requirements. In this case, there is no formal connection between RTL and system-level implementation. Therefore, there is no guarantee that the RTL and ESL models are compatible.

In \cite{paper-pdd}, a new method for RTL design, called \textit{Property-Driven Design}~(PDD), is proposed. This method is inspired by \textit{Test-Driven Development}~(TDD), an approach used in software development. In contrast to the \textit{V}-model, where testing is done closer to the end of the design process, TDD brings testing to the start of the development process. For that purpose, test cases are created even before the software product itself. This allows to find bugs in the software at earlier stages of the development process. Therefore, correcting the bugs is cheaper than it would be at later stages. Similarly, PDD is intended to bring verification to earlier stages of the design process using formal verification. In this method, a high-level description of the system is used to generate properties that should be refined concomitantly with the RTL implementation. In the end, an RTL design is achieved along with a set of properties that proves its correct behaviour. Additionally, the methodology guarantees that the \aSSREP{achieved}{obtained}\TLSAY{achieved?} RTL design \aSSREP{is sound}{corresponds} \TLSAY{What does sound mean here?} to the initial ESL model. As a result, both can be used as the golden model.

In order to apply the PDD methodology, the high-level model should be written with a subset of the SystemC \cite{lib-systemc} library, called \textit{SystemC-PPA}. The authors in \cite{paper-pdd} created a tool, called DeSCAM \cite{descam}, that reads a \textit{SystemC-PPA} compliant model and automatically generates a set of properties. As help for the designer, an RTL template that can be used as a start point of the \textit{implementation-refinement} process can be generated.

\aTLINS{The methodology works well for ..., however ...}. \aSSDEL{A major drawback to the PDD method appears for pipelined processors} \TLSAY{drawbacks dont appear}. 
\aSSINS{Even though the methodology works well for sequential models, it is not easily suitable for pipelined processors, due their concurrent behaviour.} The \textit{SystemC-PPA} model is implemented as a sequential \aSSREP{CPU}{model}\TLSAY{CPU? Model?}. Therefore, the properties will inherit this sequential behaviour and it will not be able to reflect the concurrent pipeline behaviour. This will cause the hardware designer to have an extra effort to refine these properties to fit the pipeline, or to modify the \textit{SystemC-PPA} model to simulate the pipelined behaviour. In both cases, the extra effort for the hardware designer mitigates the advantages of the PDD method.

In this work, an algorithm to generate Pipeline Properties using the PDD method is proposed. The algorithm adds an extra step to the PDD process when dealing with pipelined processors design. The properties generated from the sequential \textit{SystemC-PPA} compliant model are applied to the Pipeline Property Algorithm, which converts these properties into \textit{Pipeline Properties}. Then, the hardware designer can start the \textit{implement-refine} process without extra work.

In order to evaluate the proposed Pipeline Algorithm, a case study was conducted with the RI5CY \TLSAY{Update, Reference to new design} core. This processor is an open-source implementation based on the RISC-V instruction set architecture (ISA), and it is powered by the PULP Platform \cite{pulp}. A \textit{SystemC-PPA} compliant model for the RI5CY processor was implemented, and the proposed Pipeline Algorithm was used to generate the Pipeline Properties. In this case study, the RTL implementation is already provided, and the Pipeline Properties should hold for this implementation after the refinement process. In addition, sequential properties were manually written, classical Formal Verification process, from the RTL model. These sequential properties are then used for comparison with the generated Pipeline Properties. 

\TLSAY{I like your red line, however, you need to more precise in your formulation.} 
\SSSAY{I took your advice and used the text from the background on the introduction}
\TLSAY{Maybe you split it into two section? Introduction and Motivation or something like that?}
\SSSAY{I think motivation and goal can be included in the Introduction, right? I have only three paragraphs with the motivation/goal. If I put as separated sections (or subsections of the introduction), would I have to extend it?}
\TLSAY{1.5 pages per section is totally fine} 
\SSSAY{include the plugin that will be developed}
\SSSAY{include STRUCTURE of the thesis...}

