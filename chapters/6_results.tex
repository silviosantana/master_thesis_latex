% ----------------------------------------------------------
% Results
% ----------------------------------------------------------
\chapter{Experimental Results}
\label{chapter:results}


In Chapter \ref{chapter:ri5cy}, the ESL model for the RI5CY processor core and the generation and refinement of a complete set of properties, including the pipeline and \SSQED{} properties, are presented. \TLREP{The current}{In this} chapter \TLINS{we} discuss\TLDEL{es} the experimental results for the ESL model including a simulation comparison with the RTL implementation. In addition, the experiments analyse the property generation and property checking process. Finally, a comparison with the bottom-up verification flow is discussed. All experiments were conducted on an Intel Xeon~E5-2637~v4  @~3.50\,GHz with 96\,GB of RAM.


Table~\ref{tab:esl-rtl-comp} provides the number of \textit{Lines of Code}~(LoC) and estimated design effort for the ESL model, in addition to the simulation results for both ESL and RTL models. The LoC counting for the ESL includes the RI5CY CORE and the Register File modules. The register file is included in the counting because it is a embodied part of the core. On the other hand, the memory bridge (IMEM) and the memory itself are not considered for the LoC measurement. The estimated design effort to implement the ESL model comprises the implementation of the RI5CY CORE and the Memory interface (IMEM), and it includes the effort to understand the pipeline behavior, i.e. pipeline stages and how each instruction is executed through them, and the \textit{flushing} behaviour. There is no measure of LoC and approximated effort for the RTL model because an existent implementation was used in the case study and the PULP extensions were not considered for modeling the ESL.  

\begin{table}[htb!] 
	\centering 
	\caption{LoC and effort results for ESL model, and simulation comparison results for the ESL and RTL models.} 
	\label{tab:esl-rtl-comp}
	\begin{tabular}{p{5cm} c c} 
		  &  \multicolumn{2}{c}{\textbf{ESL}} \\     
		\hline	
		Lines of Code  & \multicolumn{2}{c}{856} \\
		Design Effort & \multicolumn{2}{c}{2 person weeks}\\
		\hline
		\textbf{Simulation Time} (s) & \textbf{ESL} & \textbf{RTL}\\
		\hline
		Prime Numbers  &  0.67 & 43 \\
		Fibonacci  &  0.10 & 42 \\
		Bubble Sort  &  0.14 & 46 \\
	\end{tabular} 
\end{table}

The simulation results presented in Table~\ref{tab:esl-rtl-comp} refer to the simulation of three computation-heavy programs for the ESL and RTL models. The first program computes ten prime numbers greater than 1000. The second one computes 1000 numbers of the Fibonacci sequence. The third program implements the execution of the \textit{Bubble Sort} algorithm to sort an array of 50 integers in ascending order. To consider the worse-case execution time for \textit{Bubble Sort}, the array is initially sorted in descending order. The simulations for the ESL model were approximately 144~times faster the RTL simulation. This expected simulation \textit{speedup} reflects the higher abstract implementation of the system-level compared to the RTL implementation.

The same environment was used to run the \textit{DeSCAM} tool for the implemented ESL model to generate the set of micro properties. The results are presented in Table~\ref{tab:micro-ppt-results}. \textit{DeSCAM} takes approximately 24\,s to parse the ESL model and generate the micro properties set with a total of 21 properties. Considering only the lines of code for the generated properties, the count is 661\,LoC. When the generated macros to be refined by the designer are considered, the new count is 925\,LoC. \textit{DeSCAM} also generates a file with macros of functions that correspond to the functions implemented at the ESL model. For this experiment, the generated file has 201 LoC, but the designer does not need to do any refinement for these macro functions.  

\begin{table*}[htb!] 
	\centering 
	\caption{Results for micro properties generated by \textit{DeSCAM} from the RI5CY ESL model.} 
	\label{tab:micro-ppt-results}
	\begin{tabular}{p{6cm} c } 
		\multicolumn{2}{c}{\textbf{Micro Properties Set}} \\  
		\hline	
		Time to generate properties  &  23.6 s  \\
		Number of properties  &  21 \\
		LoC (properties only)  &  661 \\
		LoC (properties \& macros)  &  925\\
	\end{tabular} 
\end{table*}

The next step is the creation of the set of pipeline and \SSQED{} properties. Table~\ref{tab:pipe-s2qed-ppt-resutls} shows the estimated effort for applying the pipeline algorithm to create the merged properties, and the estimated effort to create the \SSQED{} property set. Even though the \SSQED{} properties are not created from any automatically generated properties, they are not build from scratch. The number of properties needed is guided by the merged pipeline properties, i.e. for each merged property corresponding to a type of instruction, a \SSQED{} should be written. In addition, the refined state macros, e.g. \textit{ready to fetch} and \textit{empty pipeline}, and the generated function macros can be reused. The effort shown for the pipeline property set takes into consideration the application of the pipeline algorithm to merge the micro properties, but not the macros refinement.The estimated effort to refine the macros is 1\,\textit{person\,week}. This effort is considerably large because the RI5CY user manual \cite{manual-ri5cy} does not have detailed specification and much of the effort went towards extracting information from the RTL implementation.

Table~\ref{tab:pipe-s2qed-ppt-resutls} also shows the resulting number of merged and \SSQED{} properties, and the number of Lines of Code for both. The difference on the number of properties between the property sets occurs because the \SSQED{} set does not include the \textit{reset}, \textit{vacuous}, \textit{flush} and \textit{unknown} properties. In addition, there is only one \SSQED{} property for both \textit{jump} instructions. Regarding the lines of code, only the properties were taken into consideration, since the macros and functions are common for both sets.

\begin{table*}[htb!] 
	\centering 
	\caption{Results comparison between the Pipeline and \SSQED{} properties sets.} 
	\label{tab:pipe-s2qed-ppt-resutls}
	\begin{tabular}{p{5cm} c c} 
		  &  \textbf{Pipeline} & \textbf{\SSQED{}} \\     
		\hline	
		Effort  &  5 person hours & 1 person week \\
		Number of Properties  &  13 & 8 \\
		Lines of Code  &  634 & 502 \\
	\end{tabular} 
\end{table*}

Finally, the resulting property set was checked for the RTL design. The property checking was conducted with the commercial property checker OneSpin~360~DV-Certify \texttrademark{}. Table~\ref{tab:pipe-s2qed-check-resutls} shows the checking time and memory used results both pipeline and \SSQED{} property sets.

\begin{table*}[htb!] 
	\centering 
	\caption{Results for checking time and memory used for Pipeline and \SSQED{} properties sets.} 
	\label{tab:pipe-s2qed-check-resutls}
	\begin{tabular}{lcccc}
          & \multicolumn{2}{c}{\textbf{Pipeline Properties}} & \multicolumn{2}{c}{\textbf{\SSQED{} Properties}} \\
          \hline
         Instruction Type & Time (h:m) & Mem.(GB) & Time (h:m) & Mem.(GB)  \\
          \hline
        ENC\_R & 00:23 & 9.7 & 01:37 &  21.4  \\
        ENC\_I\_I & 00:19 & 9.4 & 11:27 &  26.5\\
        ENC\_B taken  & 00:02 & 8.8 & 01:12 & 19\\
        ENC\_B not taken & 00:10 & 9.4 & 01:07 &  24  \\
        ENC\_J & 00:03 & 8.7 & - &  -  \\
        ENC\_I\_J & 00:07 & 9.7 & - &  -  \\
        ENC\_JUMP & - & - & 10:27 &  23  \\
        ENC\_I\_L & 01:00 & 23.3 & 17:07 & 33.6  \\
        ENC\_S & 00:08 & 12.2 & 04:15 &  24.9  \\
        ENC\_U & 00:14 & 9.4 & 09:02 & 20.7  \\
        RESET & < 00:01 & 1.1 & - &  -  \\
        FLUSH & 00:10 & 7.8 & - &  -  \\
        UNKNOWN & < 00:01 & 5.5 & - &  -  \\
        VACUOUS & < 00:01 & 0.9 & - &  -  \\
\end{tabular}
\end{table*}

The longer checking time for the pipeline properties occurred for the \textit{ENC\_I\_L} instruction type. This is justified by the inserted bounded wait of five cycles for the data memory. The \textit{ENC\_I\_L} is followed by \textit{ENC\_R} and \textit{ENC\_I\_I} types. This is because these types comprise the greater number of associated instructions, for instance all the arithmetic, logic, and logic shift instructions.

The results for the \SSQED{} property set were obtained with some constraints regarding the number of registers considered for the checker. All the register fields of the IUV were restricted to be lower than five, i.e. the instruction will access the four first register of the register file. In addition, the bounded wait for \textit{load} and \textit{store} instructions were limited to three instead of five. These restrictions were applied to reduce the complexity for the property checker. This complexity issue is evidenced when comparing both checking time and memory used between the \SSQED{} properties set with the pipeline properties set. Both measurements are much higher for the \SSQED{} set than for the pipeline set for all instruction types.

Even though the checking time required for making a property hold can be of several minutes, or even hours, the property checking tool needs much less to find a \textit{bug}. A \textit{bug} was inserted on the forwarding mechanism of the processor core. This type of error is only detected by the \SSQED{} property set, since \textit{forwarding} only happens for specific program contexts where instructions at different pipeline stages interact. The property checking tool needed 4\,min\,and\,58\,s to find a counter-example for an \textit{ENC\_I\_L} \SSQED{} property, and only 2\,min\,and\,6\,s for an \textit{ENC\_R} \SSQED{} property. Similarly, a \textit{bug} was inserted on the operand signals from the register file to the ALU. This type of \textit{bug} is considered single-instruction error because it can be spotted by properties for IUV executing in an empty pipeline. Thus, the property checking tool found a counter-example for an \textit{ENC\_I\_L} pipeline property in 1\,min\,and\,36\,s and for an \textit{ENC\_R} pipeline property in 15\,s.

For means of comparison, the experiments included the creation of pipeline properties in a \textit{bottom-up} approach. This property set was created strictly from the behaviour extracted from the RTL design, and it is not part of the PDD flow. In this case, the properties were created from the ground up based on the implemented RTL and its signals. No automatically generated macros or functions were used. One property for each instruction was created. However, macros were employed to unify the properties of each type of instruction, and each instruction property just instantiated the corresponding macro, e.g. all arithmetic and logic instructions of R-type and I-type use the same property macro. This use of macros resulted in eight property macros.

Table~\ref{tab:bottom-up-ppt-resutls} shows the experimental results of the bottom-up constructed pipeline properties in comparison to the pipelined properties merged from the micro properties in the PDD flow. The results indicate a much larger effort to create the properties from bottom-up than with the PDD flow using an ESL model. The effort shown in the "Pipeline PDD" combines the effort for merging the properties and refining the macros in the PDD flow. The lines of code includes the code for both properties and refined macros. For the bottom-up constructed properties, the number of properties represent the number of property macros. It has less properties macros than pipeline properties because it does not have properties for unknown instruction and \textit{flushing}. In addition, all R-type and I-type arithmetic and logic instructions are described by the same macro property. The same happens for the \textit{jal} and \textit{jalr} instructions. 

\begin{table*}[htb!] 
	\centering 
	\caption{Results from comparison between pipeline properties created in a bottom-up approach and pipeline properties generated using the merging algorithm within the PDD flow.} 
	\label{tab:bottom-up-ppt-resutls}
	\begin{tabular}{p{5cm} c c} 
		  &  \textbf{Botton-up} & \textbf{Pipeline (PDD)} \\     
		\hline	
		Effort  &  1 person month &  8 person days\\
		Number of Properties  &  8 & 13 \\
		Lines of Code  & 879  &  834\\
	\end{tabular}
\end{table*}

Tables \ref{tab:bottom-up-check-resutls-arithm} and \ref{tab:bottom-up-check-resutls-others} shows the results for the running checking time and the memory used for each property. Since each instruction has its own property, a direct comparison of checking time is not possible as the pipeline properties from the PDD flow are grouped per type. Nonetheless, the total time for checking all the instructions can be compared. The checking time for the PDD pipeline properties is 2:36~h, and 9:21~h for the bottom-up properties. This time difference can not be directly associated with a complexity difference between the two sets of properties. It demonstrates, however, the advantages of having a set of instructions of the same time grouped into a single property.

\begin{table*}[htb!] 
	\centering 
	\caption{Checking time and memory used results for pipeline properties created on a bottom-up approach. Results for arithmetic and logic instructions from types \textit{ENC\_R} and \textit{ENC\_I\_I}.} 
	\label{tab:bottom-up-check-resutls-arithm}
		\begin{tabular}{p{4cm}cc}
          \multicolumn{3}{c}{\textbf{Bottom-up Pipeline Properties}} \\
          \hline
         Instruction Type & Time (min:s) & Mem.(GB)  \\
          \hline
        add     & 04:45 & 9.4  \\
        sub    & 05:09 & 9.3 \\
        sll     & 05:33 & 9.6 \\
        slt    & 04:15 & 9 \\
        sltu    & 03:44 & 9.2 \\
        xor    & 04.20 & 9 \\
        srl    & 04:06 & 9.3 \\
        sra    & 03:27 & 9 \\
        or    & 05:04 & 9.4 \\
        and    & 03:12 & 9.4 \\
        addi    & 05:08 & 9.5 \\
        slti    & 02:17 & 9.3 \\
        sltiu    & 02:29 & 9 \\
        xori    & 03:46 & 9.4 \\
        ori    & 04:13 & 9.3 \\
        andi    & 03:49 & 9.3 \\
        slli    & 04:37 & 9.6 \\
        srli    & 04.19 & 9.2 \\
        srai    & 03:37 & 9.3 \\
\end{tabular}
\end{table*}

\begin{table*}[htb!] 
	\centering 
	\caption{Checking time and memory used results for pipeline properties created on a bottom-up approach. Results for \textit{branch}, \textit{jump}, \textit{load}, \textit{store}, \textit{lui}, \textit{auipc}, and \textit{reset} instructions from types \textit{ENC\_B}, \textit{ENC\_J}, \textit{ENC\_I\_J}, \textit{ENC\_I\_L}, \textit{ENC\_S}, and \textit{ENC\_U}.} 
	\label{tab:bottom-up-check-resutls-others}
		\begin{tabular}{p{4cm}cc}
          \multicolumn{3}{c}{\textbf{Bottom-up Pipeline Properties}} \\
          \hline
         Instruction Type & Time (min:s) & Mem.(GB)  \\
          \hline
        beq taken    & 19:43 & 10.4 \\
        beq not taken     & 13:22 & 10.5 \\
        bne taken    & 23:09 & 11.7 \\
        bne not taken    & 12:28 & 9.7 \\
        blt taken    & 25:46 & 11.5 \\
        blt not taken    & 11:37 & 9.6 \\
        bge taken    & 20:10 & 10.4 \\
        bge not taken    & 15:09 & 10.2 \\
        bltu taken    & 22:06 & 12 \\
        bltu not taken    & 13:55 & 9.7 \\
        bgeu taken    & 22:08 & 10.2 \\
        bgeu not taken    & 12:35 & 10.1 \\
        jal    & 03:45 & 8.8 \\
        jalr    & 04:33 & 9.1 \\
        lb    & 37:46 & 18.3 \\
        lh    & 69:47 & 24.6 \\
        lw    & 28:06 & 19.8 \\
        lbu    & 41:42 & 16.3 \\
        lhu    & 46:22 & 20.3 \\
        sb    & 09:19 & 14.2 \\
        sh    & 10:06 & 12 \\
        sw    & 13:00 & 12.3 \\
        lui    & 03:17 & 9.3 \\
        auipc    & 03:33 & 9.2 \\
        reset    & 00:03 & 1.5 \\
\end{tabular}
\end{table*}